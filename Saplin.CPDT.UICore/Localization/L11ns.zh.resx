<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="About1" xml:space="preserve">
    <value>此应用程序使用标准操作系统的文件API（Windows上的WinAPI，Mac上的POSIX和Android上的NDK）测量存储设备（HDD，SSD，USB闪存驱动器）和系统内存（RAM）之间的数据传输速度（以兆字节/秒为单位）。 ）。 API调用通过.NET Framework / Mono完成。</value>
  </data>
  <data name="About2" xml:space="preserve">
    <value>顺序读和顺序写测试在RAM和存储之间传输大量数据（兆字节）。这些测试代表磁盘操作，例如大文件复制，视频记录/编码/解码等。</value>
  </data>
  <data name="About3" xml:space="preserve">
    <value>随机测试每次运行7秒，并在测试文件中的随机位置进行小块传输（4KB和32KB）。这些测试表明文件系统性能如何影响应用程序的加载时间，复制多个小文件，运行数据库查询等。</value>
  </data>
  <data name="About4" xml:space="preserve">
    <value>在“选项”部分，您可能会发现可能会影响测试结果的设置：</value>
  </data>
  <data name="About5" xml:space="preserve">
    <value>•写缓冲-影响写测试。写入操作使用中间存储缓冲区，将数据推迟到后面的更方便的时间以提供更好的性能，但以较少的弹性写入为代价（例如电源故障并且不提交磁盘写入缓冲区内容）。</value>
  </data>
  <data name="About6" xml:space="preserve">
    <value>•内存中文件缓存-影响读取测试。任何文件操作都需要操作系统将文件数据传输到内存或将内存数据传输到磁盘，操作系统会将这些内存页面保留在RAM中，直到其他应用程序要求RAM压力为止。如果操作系统通过API接收到后续的文件读/写请求，它将仅从先前的文件操作中复制缓存的内存页面，而不使用实际的存储设备。启用此选项对于测试OS的文件缓存子系统和RAM速度至关重要，而不是对存储设备进行测试。</value>
  </data>
  <data name="About7" xml:space="preserve">
    <value>处理器（CPU）对加载在系统内存（RAM）中的数据执行计算机和智能手机上的操作。该内存不是永久性的，而且大小不受限制，这就是为什么总会有一个永久性存储（SSD，HDD，SD卡-亦称“磁盘/驱动器”）的原因。在许多情况下，系统的性能不仅取决于CPU（通常是广告宣传和众多基准测试的目标），还取决于内存的性能，尤其是RAM和存储的性能。官方规格（尤其是智能手机）对容量以外的存储特性几乎没有描述。此应用程序试图通过隔离和测量3个方面来给出清晰的存储器性能特征：读取速度（从DRIVE到RAM的传输）。写入（RAM到驱动器）和系统内存（将数据从RAM中的一个区域复制到另一区域）。</value>
  </data>
  <data name="About8" xml:space="preserve">
    <value>该应用程序是开源的，您可能想在以下位置查看项目的GitHub：</value>
  </data>
  <data name="AndroidSameAliases" xml:space="preserve">
    <value>相同的驱动器，不同的别名</value>
  </data>
  <data name="AvailableDrives" xml:space="preserve">
    <value>可用驱动器：</value>
  </data>
  <data name="b" xml:space="preserve">
    <value>乙</value>
  </data>
  <data name="Block" xml:space="preserve">
    <value>块</value>
  </data>
  <data name="bps" xml:space="preserve">
    <value>每秒</value>
  </data>
  <data name="BreakTest" xml:space="preserve">
    <value>[Esc, B]打断</value>
  </data>
  <data name="Close" xml:space="preserve">
    <value>[Esc, C]关</value>
  </data>
  <data name="CsvOption" xml:space="preserve">
    <value>[E]导出为CSV:</value>
  </data>
  <data name="FileSizeOption" xml:space="preserve">
    <value>[F]文件大小:</value>
  </data>
  <data name="gb" xml:space="preserve">
    <value>GB</value>
  </data>
  <data name="GbFree" xml:space="preserve">
    <value>不含GB</value>
  </data>
  <data name="gbps" xml:space="preserve">
    <value>GB/s</value>
  </data>
  <data name="HelpButton" xml:space="preserve">
    <value>[?]关于</value>
  </data>
  <data name="HintAndroid" xml:space="preserve">
    <value>要开始点击上面列表中的驱动器</value>
  </data>
  <data name="HintMisc" xml:space="preserve">
    <value>要开始测试，请单击上方列表中的驱动器，或按数字键</value>
  </data>
  <data name="kb" xml:space="preserve">
    <value>KB</value>
  </data>
  <data name="kbps" xml:space="preserve">
    <value>KB/s</value>
  </data>
  <data name="Language" xml:space="preserve">
    <value>[L]语言:</value>
  </data>
  <data name="Max" xml:space="preserve">
    <value>最高</value>
  </data>
  <data name="mb" xml:space="preserve">
    <value>MB</value>
  </data>
  <data name="mbps" xml:space="preserve">
    <value>MB/s</value>
  </data>
  <data name="MemCacheOption" xml:space="preserve">
    <value>[M]内存缓存</value>
  </data>
  <data name="MemCopyTest" xml:space="preserve">
    <value>记忆复制</value>
  </data>
  <data name="MemCopyTestShort" xml:space="preserve">
    <value>记忆复制</value>
  </data>
  <data name="MemCopyTestShortNB" xml:space="preserve">
    <value>记忆复制</value>
  </data>
  <data name="Compare" xml:space="preserve">
    <value>⇆比较</value>
  </data>
  <data name="Share" xml:space="preserve">
    <value>⬑分享⬏</value>
  </data>
  <data name="ShareTitle" xml:space="preserve">
    <value>CPDT基准测试：https://play.google.com/store/apps/details?id=com.Saplin.CPDT</value>
  </data>
  <data name="Min" xml:space="preserve">
    <value>敏</value>
  </data>
  <data name="Off" xml:space="preserve">
    <value>（关）</value>
  </data>
  <data name="On" xml:space="preserve">
    <value>（上）</value>
  </data>
  <data name="OptionsButton" xml:space="preserve">
    <value>[O]选件</value>
  </data>
  <data name="PickDrive" xml:space="preserve">
    <value>-选择任何驱动器对其进行性能测试</value>
  </data>
  <data name="ProjectLink" xml:space="preserve">
    <value>https://github.com/maxim-saplin/CrossPlatformDiskTest</value>
  </data>
  <data name="Quit" xml:space="preserve">
    <value>[放弃</value>
  </data>
  <data name="Quiting" xml:space="preserve">
    <value>正在终止申请...</value>
  </data>
  <data name="RandomReadTest" xml:space="preserve">
    <value>随机读取</value>
  </data>
  <data name="RandomReadTestShort" xml:space="preserve">
    <value>随机读取</value>
  </data>
  <data name="RandomReadTestShortNB" xml:space="preserve">
    <value>随机读取</value>
  </data>
  <data name="RandomWriteTest" xml:space="preserve">
    <value>随机写</value>
  </data>
  <data name="RandomWriteTestShort" xml:space="preserve">
    <value>随机写</value>
  </data>
  <data name="RandomWriteTestShortNB" xml:space="preserve">
    <value>随机写</value>
  </data>
  <data name="RefreshButton" xml:space="preserve">
    <value>[R]刷新</value>
  </data>
  <data name="SequentialReadTest" xml:space="preserve">
    <value>顺序读取</value>
  </data>
  <data name="SequentialReadTestShort" xml:space="preserve">
    <value>顺序读取</value>
  </data>
  <data name="SequentialReadTestShortNB" xml:space="preserve">
    <value>顺序读取</value>
  </data>
  <data name="SequentialWriteTest" xml:space="preserve">
    <value>顺序写入</value>
  </data>
  <data name="SequentialWriteTestShort" xml:space="preserve">
    <value>顺序写入</value>
  </data>
  <data name="SequentialWriteTestShortNB" xml:space="preserve">
    <value>顺序写入</value>
  </data>
  <data name="StatusBreakingTest" xml:space="preserve">
    <value>突破测试</value>
  </data>
  <data name="StatusTestCompleted" xml:space="preserve">
    <value>测试已完成执行。测试文件已删除</value>
  </data>
  <data name="StatusTestCsvCompleted" xml:space="preserve">
    <value>测试执行完成。测试结果导出到CSV文件</value>
  </data>
  <data name="StatusTestError" xml:space="preserve">
    <value>测试执行由于错误而中断</value>
  </data>
  <data name="StatusTestInterrupted" xml:space="preserve">
    <value>测试执行中断。测试文件已删除</value>
  </data>
  <data name="TestInitMemBuffer" xml:space="preserve">
    <value>正在初始化RAM中的测试数据...</value>
  </data>
  <data name="TestNotEnoughMemory" xml:space="preserve">
    <value>内存不足</value>
  </data>
  <data name="TestPurgingMemCache" xml:space="preserve">
    <value>正在清除内存缓存...</value>
  </data>
  <data name="TestRunning" xml:space="preserve">
    <value>正在运行测试...</value>
  </data>
  <data name="TestStarted" xml:space="preserve">
    <value>测试开始</value>
  </data>
  <data name="TestSummaryFormatString" xml:space="preserve">
    <value>档案大小：{0} GB。可用空间：{1:0.0} GB。写缓冲：{2}。内存中文件缓存：{3}</value>
  </data>
  <data name="TestSummaryShortFormatString" xml:space="preserve">
    <value>档案大小：{0} GB。可用空间：{1:0.0} GB。写缓冲：{2}。内存中文件缓存：{3}</value>
  </data>
  <data name="TestWarmigUp" xml:space="preserve">
    <value>热身...</value>
  </data>
  <data name="WhiteTheme" xml:space="preserve">
    <value>[W]白色主题</value>
  </data>
  <data name="WriteBufferingOption" xml:space="preserve">
    <value>[B]写缓冲</value>
  </data>
  <data name="CClose" xml:space="preserve">
    <value>关</value>
  </data>
  <data name="Database" xml:space="preserve">
    <value>[D]数据库</value>
  </data>
  <data name="DbNotAvailable" xml:space="preserve">
    <value>结果数据库不可用。检查互联网连接</value>
  </data>
  <data name="DownloadLink" xml:space="preserve">
    <value>https://maxim-saplin.github.io/cpdt_results/?download=&amp;lang=zh-CN&amp;app=</value>
  </data>
  <data name="About9" xml:space="preserve">
    <value>您可以通过以下链接下载适用于不同平台（Windows，macOS，Android / APK）的应用程序：</value>
  </data>
  <data name="DownloadLinkShort" xml:space="preserve">
    <value>https://maxim-saplin.github.io/cpdt_results/?download=</value>
  </data>
  <data name="ModeH" xml:space="preserve">
    <value>模式</value>
  </data>
  <data name="About10" xml:space="preserve">
    <value>每个测试都有一个图表。顺序和内存复制测试显示了针对块位置绘制的即时吞吐量（单个块的度量）。即您可以看到速度随着读写过程向测试文件末尾的方向变化。例如。您可能会注意到，有时存储在操作开始时会出现滞后现象（对于Android典型）。随机测试显示直方图，其中每个人的数据块吞吐量都放置在特定的bin /范围内，而该图则显示了读写速度如何根据其速度分布。可以将长尾巴减至最小，即，低端和高端的那些ththoththoth（每个量的总和少于总测量值的3％）将组合到图的左侧和右侧的单个bin中。如果在直方图的侧面上有带有箭头的垂直线，则表示尾巴已最小化（在某些情况下不需要），带有箭头的线之间的仓位占所有度量的94％（最小值和最大值）在这种情况下，将其拖到尾部，并且不显示绝对测得的最小值和最大值。用2个箭头概述的垃圾箱是“模式”-最频繁的垃圾箱的吞吐量值（垃圾箱范围的中点）。</value>
  </data>
  <data name="SimpleUI_StartA" xml:space="preserve">
    <value>开始</value>
  </data>
  <data name="SimpleUI_Test" xml:space="preserve">
    <value>[测试</value>
  </data>
  <data name="SimpleUI_OrSee" xml:space="preserve">
    <value>看到</value>
  </data>
  <data name="SimpleUI_More" xml:space="preserve">
    <value>[更多</value>
  </data>
  <data name="SimpleUIOption" xml:space="preserve">
    <value>[S]分享</value>
  </data>
  <data name="CantTestNotEnough" xml:space="preserve">
    <value>无法测试某些驱动器。需要{0} GB可用空间</value>
  </data>
  <data name="TestOf" xml:space="preserve">
    <value>测试{1}之{0}</value>
  </data>
  <data name="TestTotal" xml:space="preserve">
    <value>完成{0:0}％</value>
  </data>
  <data name="InitDrivesError" xml:space="preserve">
    <value>提取可用驱动器/分区列表时发生错误。测试无法执行。</value>
  </data>
  <data name="NotEnoughSpaceHint" xml:space="preserve">
    <value>不够</value>
  </data>
  <data name="NotAccessibleDriveHint" xml:space="preserve">
    <value>不可用</value>
  </data>
</root>